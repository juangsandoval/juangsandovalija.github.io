<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>FILLER 3.0 </title>

    <style>
      :root {
        --accent: #00695c;
        --bg: #fafbfc;
        --fg: #222;
        --border: #e0e0e0;
        --radius: 8px;
      }
      body {
        font-family: system-ui, sans-serif;
        background: var(--bg);
        color: var(--fg);
        margin: 32px auto;
        max-width: 900px;
        line-height: 1.6;
      }
      h1 {
        font-size: 1.5rem;
        color: var(--accent);
        margin-bottom: 0.5em;
        font-weight: 600;
      }
      fieldset {
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: #fff;
        padding: 1.5em;
        margin-bottom: 1.5em;
        box-shadow: none;
      }
      legend {
        font-weight: 600;
        color: var(--accent);
        padding: 0 0.5em;
      }
      label {
        font-size: 1em;
        font-weight: 500;
        margin-bottom: 0.25em;
        display: block;
      }
      input,
      select {
        width: 100%;
        padding: 0.6em;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        background: #fafbfc;
        font-size: 1em;
        margin-bottom: 1em;
        box-sizing: border-box;
      }
      input[type="checkbox"] {
        width: auto;
        margin-right: 0.5em;
      }
      button {
        border: none;
        border-radius: var(--radius);
        padding: 0.7em 1.2em;
        font-size: 1em;
        font-weight: 500;
        background: var(--accent);
        color: #fff;
        cursor: pointer;
        margin-right: 0.5em;
        margin-bottom: 0.5em;
        transition: background 0.2s;
      }
      button.info {
        background: #0288d1;
      }
      button.warn {
        background: #fbc02d;
        color: #222;
      }
      button:active {
        opacity: 0.9;
      }
      .note {
        background: #e0f2f1;
        border-left: 3px solid var(--accent);
        padding: 1em;
        border-radius: var(--radius);
        margin-bottom: 1em;
      }
      pre {
        background: #f5f5f5;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 1em;
        font-family: ui-monospace, monospace;
        font-size: 0.98em;
        overflow-x: auto;
      }
      .row {
        display: flex;
        gap: 1em;
        margin-bottom: 1em;
        flex-wrap: wrap;
      }
      .row > div {
        flex: 1 1 220px;
        min-width: 180px;
      }
      .actions {
        margin-top: 1em;
        display: flex;
        gap: 0.5em;
        flex-wrap: wrap;
      }
      .muted {
        color: #888;
        font-size: 0.98em;
        margin-bottom: 1.5em;
      }
      .small {
        font-size: 0.92em;
        color: #666;
      }
      .danger {
        color: #c62828;
      }
      .iconbtn {
        width: 40px;
        padding: 0.4em;
        text-align: center;
      }
      hr {
        border: 0;
        border-top: 1px solid var(--border);
        margin: 1.5em 0;
      }
    </style>
  </head>
  <body>
    <h2>FILLER 3.0</h2>

    <div>
      <label>1) Selecciona tu plantilla <small>(.docx)</small></label>
      <input id="fileInput" type="file" accept=".docx" />
      <div class="small">
        Usa marcadores como <code>{{DEMANDANTE}}</code>, <code>{{RADICADO}}</code> o
        <code>{{sentencia.consecutivo}}</code>.
      </div>
    </div>

    <hr />

    <div id="formArea"></div>

    <div style="margin-top: 12px">
      <button id="generateBtn" disabled>Generar y descargar DOCX</button>
      <button id="reloadBtn" class="hidden">Cargar otra plantilla</button>
    </div>

    <div id="log" aria-live="polite"></div>

    <script>
      (function () {
        const fileInput = document.getElementById("fileInput");
        const formArea = document.getElementById("formArea");
        const generateBtn = document.getElementById("generateBtn");
        const reloadBtn = document.getElementById("reloadBtn");
        const logEl = document.getElementById("log");

        let originalZip = null;
        let templateFilename = null;
        let detectedVars = [];

        // Carga secuencial de scripts con fallback URLs
        function loadScript(url) {
          return new Promise((resolve, reject) => {
            const s = document.createElement("script");
            s.src = url;
            s.async = true;
            s.onload = () => resolve(url);
            s.onerror = () => reject(url);
            document.head.appendChild(s);
          });
        }

        async function ensurePizzipAndSaver() {
          // intentamos varios CDNs por robustez
          const pizUrls = [
            "https://unpkg.com/pizzip@3.1.8/dist/pizzip.min.js",
            "https://cdnjs.cloudflare.com/ajax/libs/pizzip/3.1.5/pizzip.min.js",
          ];
          const saverUrls = [
            "https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js",
            "https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/1.3.8/FileSaver.js",
          ];

          // cargar PizZip
          let pizLoaded = false;
          for (const u of pizUrls) {
            try {
              await loadScript(u);
              // algunos bundles exponen como PizZip o window.PizZip
              if (
                typeof window.PizZip !== "undefined" ||
                typeof PizZip !== "undefined"
              ) {
                window.PizZip =
                  window.PizZip ||
                  (typeof PizZip !== "undefined" ? PizZip : undefined);
                pizLoaded = true;
                break;
              }
            } catch (e) {
              /* try next */
            }
          }
          if (!pizLoaded)
            throw new Error("No se pudo cargar PizZip desde CDN.");

          // cargar FileSaver
          let saverLoaded = false;
          for (const u of saverUrls) {
            try {
              await loadScript(u);
              if (typeof saveAs !== "undefined") {
                saverLoaded = true;
                break;
              }
            } catch (e) {
              /* try next */
            }
          }
          if (!saverLoaded)
            throw new Error("No se pudo cargar FileSaver desde CDN.");
        }

        function log(msg) {
          console.log(msg);
          logEl.textContent += msg + "\n";
          logEl.scrollTop = logEl.scrollHeight;
        }

        // escape XML text for safe insertion into <w:t>
        function escapeXml(s) {
          if (s == null) return "";
          return String(s)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
        }

        // set nested by dotted key
        function setDeep(obj, dottedKey, value) {
          const parts = dottedKey.split(".");
          let cur = obj;
          for (let i = 0; i < parts.length - 1; i++) {
            const p = parts[i];
            if (!(p in cur) || typeof cur[p] !== "object") cur[p] = {};
            cur = cur[p];
          }
          cur[parts[parts.length - 1]] = value;
        }

        // Extrae variables de un zip (recomponiendo runs <w:t>)
        function extractVarsFromZip(zip) {
          const files = Object.keys(zip.files || {});
          const placeholderRegex = /{{\s*([\w.]+)\s*}}/g;
          const xmlNames = files.filter(
            (n) => n.startsWith("word/") && n.endsWith(".xml")
          );
          const varsSet = new Set();

          for (const name of xmlNames) {
            const fileObj = zip.file(name);
            if (!fileObj) continue;
            let xml;
            try {
              if (typeof fileObj.asText === "function") xml = fileObj.asText();
              else if (typeof fileObj.asUint8Array === "function")
                xml = new TextDecoder("utf-8").decode(fileObj.asUint8Array());
              else xml = fileObj.asBinary ? fileObj.asBinary() : "";
            } catch (e) {
              console.warn("No se pudo leer", name, e);
              continue;
            }

            // conseguir todos los contenidos de <w:t>
            const tRegex = /<w:t[^>]*>([\s\S]*?)<\/w:t>/g;
            let parts = [],
              m;
            while ((m = tRegex.exec(xml)) !== null) {
              parts.push(m[1]);
            }
            const combined = parts.join("");
            let mm;
            placeholderRegex.lastIndex = 0;
            while ((mm = placeholderRegex.exec(combined)) !== null) {
              varsSet.add(mm[1]);
            }
          }
          return Array.from(varsSet);
        }

        // Construye formulario
        function buildForm(vars) {
          formArea.innerHTML = "";
          if (!vars || vars.length === 0) {
            formArea.innerHTML =
              "<p><i>No se detectaron variables {{...}} en la plantilla.</i></p>";
            generateBtn.disabled = true;
            return;
          }
          const info = document.createElement("div");
          info.innerHTML = `<p><b>Variables detectadas:</b> ${vars.join(
            ", "
          )}</p>`;
          formArea.appendChild(info);

          const container = document.createElement("div");
          container.id = "fields";
          formArea.appendChild(container);

          vars.forEach((v) => {
            const field = document.createElement("div");
            field.className = "field";
            const label = document.createElement("label");
            label.textContent = v;
            label.htmlFor = "v__" + v.replace(/[^\w]/g, "_");
            field.appendChild(label);

            if (/fecha|date/i.test(v)) {
              const inp = document.createElement("input");
              inp.type = "date";
              inp.id = "v__" + v.replace(/[^\w]/g, "_");
              field.appendChild(inp);
            } else {
              const inp = document.createElement("input");
              inp.type = "text";
              inp.id = "v__" + v.replace(/[^\w]/g, "_");
              inp.placeholder = "Valor para " + v;
              field.appendChild(inp);
            }
            container.appendChild(field);
          });

          generateBtn.disabled = false;
          reloadBtn.classList.remove("hidden");
        }

        // lee contexto del form respectando dot notation
        function readContextFromForm(vars) {
          const ctx = {};
          vars.forEach((v) => {
            const id = "v__" + v.replace(/[^\w]/g, "_");
            const el = document.getElementById(id);
            if (!el) return;
            let val = el.value;
            // si es date, dejamos ISO (puedes formatear si quieres)
            setDeep(ctx, v, val);
          });
          return ctx;
        }

        // Reemplaza placeholders dentro de un xml actuando sobre los <w:t> (runs).
        // Strategy: obtenemos array of run texts, calculamos posiciones en concatenación y reemplazamos por completo
        function replacePlaceholdersInXml(xml, replacements) {
          // obtener runs
          const tRegex = /(<w:t[^>]*>)([\s\S]*?)(<\/w:t>)/g;
          let runs = [];
          let match;
          while ((match = tRegex.exec(xml)) !== null) {
            runs.push({
              prefix: match[1],
              text: match[2],
              suffix: match[3],
              start: match.index,
              full: match[0],
            });
          }
          if (runs.length === 0) return xml; // nada que hacer

          // texts y longitudes
          const texts = runs.map((r) => r.text || "");
          const cum = [];
          let s = 0;
          for (let i = 0; i < texts.length; i++) {
            s += texts[i].length;
            cum.push(s);
          }
          const combined = texts.join("");

          // buscar placeholders en combined
          const placeholderRegex = /{{\s*([\w.]+)\s*}}/g;
          const matches = [];
          let mm;
          while ((mm = placeholderRegex.exec(combined)) !== null) {
            matches.push({
              full: mm[0],
              key: mm[1],
              index: mm.index,
              length: mm[0].length,
            });
          }
          if (matches.length === 0) return xml;

          // procesar desde el final para evitar conflictos de índice
          for (let mi = matches.length - 1; mi >= 0; mi--) {
            const m = matches[mi];
            const startIdx = m.index;
            const endIdx = m.index + m.length - 1;
            // encontrar startRun
            let startRun = 0;
            while (startRun < cum.length && startIdx >= cum[startRun])
              startRun++;
            const runStartOffset =
              startRun === 0 ? startIdx : startIdx - cum[startRun - 1];
            // encontrar endRun
            let endRun = 0;
            while (endRun < cum.length && endIdx >= cum[endRun]) endRun++;
            const runEndOffset =
              endRun === 0 ? endIdx : endIdx - cum[endRun - 1];

            // replacement value
            const replRaw = m.key in replacements ? replacements[m.key] : "";
            const repl = escapeXml(String(replRaw));

            // build new text for startRun: prefix text before placeholder + replacement + suffix from endRun after placeholder
            const before = texts[startRun].slice(0, runStartOffset);
            const after = texts[endRun].slice(runEndOffset + 1);
            texts[startRun] = before + repl + after;

            // blank the middle runs
            for (let r = startRun + 1; r <= endRun; r++) texts[r] = "";
          }

          // reconstruir xml reemplazando solo el contenido de cada run
          let out = "";
          let lastIndex = 0;
          let ri = 0;
          tRegex.lastIndex = 0;
          // construiremos xml paso a paso: iteramos sobre las coincidencias originales con exec otra vez
          let outXml = "";
          let curPos = 0;
          while ((match = tRegex.exec(xml)) !== null) {
            outXml += xml.slice(curPos, match.index); // lo que hay entre runs
            outXml += runs[ri].prefix + texts[ri] + runs[ri].suffix;
            curPos = match.index + match[0].length;
            ri++;
          }
          outXml += xml.slice(curPos); // resto del xml
          return outXml;
        }

        // Generar y descargar: aplicamos reemplazos a todos los word/*.xml del ZIP
        function generateAndDownload() {
          try {
            if (!originalZip) {
              log("No hay plantilla cargada.");
              return;
            }
            const ctx = readContextFromForm(detectedVars);
            // map de reemplazos "llave"->valor (aquí las claves son literales incl. puntos)
            const replacements = {};
            detectedVars.forEach((k) => {
              // obtener value desde ctx: buscaremos recursivamente
              const parts = k.split(".");
              let cur = ctx;
              let val = "";
              for (const p of parts) {
                if (cur && typeof cur === "object" && p in cur) cur = cur[p];
                else {
                  cur = null;
                  break;
                }
              }
              if (cur != null && cur !== undefined) val = cur;
              replacements[k] = val;
            });

            // clone zip (usamos generate then re-open to avoid mutating original file objects)
            const ab = originalZip.generate
              ? originalZip.generate({ type: "arraybuffer" })
              : originalZip;
            const zip2 = new PizZip(ab);

            const files = Object.keys(zip2.files || {});
            const xmlNames = files.filter(
              (n) => n.startsWith("word/") && n.endsWith(".xml")
            );
            for (const name of xmlNames) {
              const f = zip2.file(name);
              if (!f) continue;
              let xml;
              try {
                xml = f.asText
                  ? f.asText()
                  : new TextDecoder("utf-8").decode(f.asUint8Array());
              } catch (e) {
                console.warn("No se pudo leer", name, e);
                continue;
              }
              const newXml = replacePlaceholdersInXml(xml, replacements);
              // si cambió, actualizar
              if (newXml !== xml) {
                zip2.file(name, newXml);
              }
            }

            const outBlob = zip2.generate({
              type: "blob",
              mimeType:
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            });
            const base = (templateFilename || "plantilla").replace(
              /\.docx$/i,
              ""
            );
            const ts = new Date().toISOString().replace(/[:.]/g, "-");
            const outName = `${base}_relleno_${ts}.docx`;
            saveAs(outBlob, outName);
            log("✅ Documento generado: " + outName);
          } catch (err) {
            console.error(err);
            log(
              "❌ Error al generar: " + (err && err.message ? err.message : err)
            );
          }
        }

        // HANDLER de archivo
        async function onFileSelected(ev) {
          logEl.textContent = "";
          generateBtn.disabled = true;
          formArea.innerHTML = "<p>Procesando plantilla…</p>";
          detectedVars = [];
          const f = ev.target.files && ev.target.files[0];
          if (!f) {
            formArea.innerHTML = "<p>No seleccionaste archivo.</p>";
            return;
          }
          templateFilename = f.name;

          try {
            await ensurePizzipAndSaver();
          } catch (e) {
            formArea.innerHTML = `<p style="color:crimson">Error cargando dependencias: ${e.message}</p>`;
            log("Error al cargar librerías: " + e.message);
            return;
          }

          const reader = new FileReader();
          reader.onload = function (e) {
            try {
              const arrayBuffer = e.target.result;
              const zip = new PizZip(arrayBuffer);
              originalZip = zip;
              detectedVars = extractVarsFromZip(zip);

              if (detectedVars.length === 0) {
                formArea.innerHTML =
                  "<p><i>No se encontraron variables {{...}}. Asegúrate de usar llaves dobles y que las llaves + nombre estén en el mismo estilo o, si están partidas, que el documento no use campos especiales complicados.</i></p>";
                log("No se detectaron variables.");
                generateBtn.disabled = true;
                return;
              }

              buildForm(detectedVars);
              log("Plantilla procesada. Variables: " + detectedVars.join(", "));
            } catch (err) {
              console.error(err);
              formArea.innerHTML =
                "<p style='color:crimson'>Error procesando el .docx: " +
                (err && err.message ? err.message : err) +
                "</p>";
              log("Error interno: " + (err && err.stack ? err.stack : err));
              generateBtn.disabled = true;
            }
          };
          reader.readAsArrayBuffer(f);
        }

        // Inicialización
        fileInput.addEventListener("change", onFileSelected);
        generateBtn.addEventListener("click", generateAndDownload);
        reloadBtn.addEventListener("click", () => {
          fileInput.value = "";
          formArea.innerHTML = "";
          logEl.textContent = "";
          generateBtn.disabled = true;
          reloadBtn.classList.add("hidden");
        });
      })();
    </script>
  </body>
</html>
